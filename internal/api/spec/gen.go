//go:build go1.22

// Package spec provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package spec

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for JarAccess.
const (
	AccessPrivate JarAccess = 1
	AccessPublic  JarAccess = 0
)

// Activate defines model for Activate.
type Activate struct {
	Token string `json:"token"`
}

// Auth defines model for Auth.
type Auth struct {
	Email    openapi_types.Email `json:"email"`
	Password string              `json:"password"`
}

// AuthTokens defines model for AuthTokens.
type AuthTokens struct {
	Authorization Token `json:"authorization"`
	Refresh       Token `json:"refresh"`
}

// Error defines model for Error.
type Error struct {
	Error string `json:"error,omitempty"`
}

// FieldError defines model for FieldError.
type FieldError struct {
	// Field array showing nested location of errorous field
	Field []string `json:"field"`

	// Msg error message
	Msg string `json:"msg"`
}

// Jar defines model for Jar.
type Jar struct {
	Access    JarAccess                `json:"access"`
	CreatedAt pgtype.Timestamptz       `json:"created_at"`
	ExpiresAt pgtype.Timestamptz       `json:"expires_at"`
	ID        string                   `json:"id"`
	Name      string                   `json:"name,omitempty"`
	Tags      pgtype.FlatArray[string] `json:"tags"`
	URI       string                   `json:"uri"`
}

// JarAccess defines model for JarAccess.
type JarAccess int

// JarCollection defines model for JarCollection.
type JarCollection = []Jar

// JarCreationResponse defines model for JarCreationResponse.
type JarCreationResponse struct {
	Jar     Jar                      `json:"jar"`
	Scrolls []ScrollCreationResponse `json:"scrolls"`
}

// JarCreationType defines model for JarCreationType.
type JarCreationType struct {
	Access   JarAccess            `json:"access,omitempty"`
	Expiry   ExpiryDuration       `json:"expiry,omitempty"`
	Name     string               `json:"name"`
	Password string               `json:"password,omitempty"`
	Scrolls  []ScrollCreationType `json:"scrolls"`
	Tags     []string             `json:"tags,omitempty"`
}

// Message defines model for Message.
type Message struct {
	Message string `json:"message,omitempty"`
}

// Ping defines model for Ping.
type Ping struct {
	Environment string `json:"environment"`
	Status      string `json:"status"`
	Uptime      string `json:"uptime"`
	Version     string `json:"version"`
}

// Registration defines model for Registration.
type Registration struct {
	Email    openapi_types.Email `json:"email"`
	Password string              `json:"password"`
	Username string              `json:"username"`
}

// Scroll defines model for Scroll.
type Scroll struct {
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	Format    string             `json:"format,omitempty"`
	ID        string             `json:"id"`
	JarID     string             `json:"jarid"`
	Title     string             `json:"title,omitempty"`
	URI       string             `json:"uri"`
}

// ScrollCollection defines model for ScrollCollection.
type ScrollCollection = []Scroll

// ScrollCreationResponse defines model for ScrollCreationResponse.
type ScrollCreationResponse struct {
	Scroll      Scroll `json:"scroll,omitempty"`
	UploadToken string `json:"upload_token"`
}

// ScrollCreationType defines model for ScrollCreationType.
type ScrollCreationType struct {
	Format string `json:"format,omitempty"`
	Title  string `json:"title,omitempty"`
}

// ScrollFetch defines model for ScrollFetch.
type ScrollFetch struct {
	FetchURL string `json:"fetch_url,omitempty"`
	Scroll   Scroll `json:"scroll,omitempty"`
}

// ScrollPatch defines model for ScrollPatch.
type ScrollPatch struct {
	Format *string `json:"format,omitempty"`
	Title  *string `json:"title,omitempty"`
}

// Token defines model for Token.
type Token struct {
	Expiry time.Time `json:"expiry"`
	Token  string    `json:"token"`
}

// User defines model for User.
type User struct {
	CreatedAt time.Time `json:"created_at"`
	ID        int64     `json:"id"`
	Username  string    `json:"username"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	Errors []FieldError `json:"errors,omitempty"`
}

// JarID defines model for JarId.
type JarID = string

// ScrollID defines model for ScrollId.
type ScrollID = string

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse = Error

// JarCollectionResponse defines model for JarCollectionResponse.
type JarCollectionResponse = JarCollection

// JarResponse defines model for JarResponse.
type JarResponse = Jar

// NotFoundResponse defines model for NotFoundResponse.
type NotFoundResponse = Error

// RateLimitExceeded defines model for RateLimitExceeded.
type RateLimitExceeded = Error

// ScrollCollectionResponse defines model for ScrollCollectionResponse.
type ScrollCollectionResponse = ScrollCollection

// ScrollFetchResponse defines model for ScrollFetchResponse.
type ScrollFetchResponse = ScrollFetch

// SuccessfulMessageResponse defines model for SuccessfulMessageResponse.
type SuccessfulMessageResponse = Message

// UnauthorizedResponse defines model for UnauthorizedResponse.
type UnauthorizedResponse = Error

// UserResponse defines model for UserResponse.
type UserResponse = User

// ValidationErrorResponse defines model for ValidationErrorResponse.
type ValidationErrorResponse = ValidationError

// JarCreation defines model for JarCreation.
type JarCreation = JarCreationType

// ScrollCreation defines model for ScrollCreation.
type ScrollCreation = ScrollCreationType

// GetJarParams defines parameters for GetJar.
type GetJarParams struct {
	// XPastePassword Optional password for password protected jar
	XPastePassword string `json:"X-Paste-Password,omitempty"`
}

// GetScrollParams defines parameters for GetScroll.
type GetScrollParams struct {
	// XPastePassword Optional password for password protected jar
	XPastePassword string `json:"X-Paste-Password,omitempty"`
}

// UploadScrollParams defines parameters for UploadScroll.
type UploadScrollParams struct {
	// XUploadToken Upload token to upload the content
	XUploadToken string `json:"X-Upload-Token"`
}

// CreateJarJSONRequestBody defines body for CreateJar for application/json ContentType.
type CreateJarJSONRequestBody = JarCreationType

// PatchScrollJSONRequestBody defines body for PatchScroll for application/json ContentType.
type PatchScrollJSONRequestBody = ScrollPatch

// CreateScrollJSONRequestBody defines body for CreateScroll for application/json ContentType.
type CreateScrollJSONRequestBody = ScrollCreationType

// CreateActivationTokenJSONRequestBody defines body for CreateActivationToken for application/json ContentType.
type CreateActivationTokenJSONRequestBody = Auth

// ActivateUserJSONRequestBody defines body for ActivateUser for application/json ContentType.
type ActivateUserJSONRequestBody = Activate

// AuthUserJSONRequestBody defines body for AuthUser for application/json ContentType.
type AuthUserJSONRequestBody = Auth

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = Registration

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Route to create a new Jar
	// (POST /jar)
	CreateJar(w http.ResponseWriter, r *http.Request)
	// Route to delete a Jar. Deleting a Jar will all the scrolls within it.
	// (DELETE /jar/{id})
	DeleteJar(w http.ResponseWriter, r *http.Request, id JarID)
	// Route to get a jar information
	// (GET /jar/{id})
	GetJar(w http.ResponseWriter, r *http.Request, id JarID, params GetJarParams)
	// Route to get all scrolls of a Jar
	// (GET /jar/{id}/scrolls)
	GetJarScrolls(w http.ResponseWriter, r *http.Request, id JarID)
	// Ping to get health of server.
	// (GET /ping)
	Ping(w http.ResponseWriter, r *http.Request)
	// Route to delete a scroll
	// (DELETE /scroll/{id})
	DeleteScroll(w http.ResponseWriter, r *http.Request, id ScrollID)
	// Route to get a scroll information
	// (GET /scroll/{id})
	GetScroll(w http.ResponseWriter, r *http.Request, id ScrollID, params GetScrollParams)
	// Route to update a scroll
	// (PATCH /scroll/{id})
	PatchScroll(w http.ResponseWriter, r *http.Request, id ScrollID)
	// Route to create a new Scroll
	// (POST /scroll/{id})
	CreateScroll(w http.ResponseWriter, r *http.Request, id JarID)
	// Route to get a activation token of a user
	// (POST /token/activation)
	CreateActivationToken(w http.ResponseWriter, r *http.Request)
	// Route to upload the scroll content
	// (PUT /upload)
	UploadScroll(w http.ResponseWriter, r *http.Request, params UploadScrollParams)
	// Route to get information about the user and the jars created by them
	// (GET /user)
	GetUser(w http.ResponseWriter, r *http.Request)
	// Route to activate a new User
	// (PUT /user/activate)
	ActivateUser(w http.ResponseWriter, r *http.Request)
	// Route to authenticate and get an access token
	// (POST /user/auth)
	AuthUser(w http.ResponseWriter, r *http.Request)
	// Route to get list of jars creatd by the user
	// (GET /user/jars)
	GetUserJars(w http.ResponseWriter, r *http.Request)
	// Route to create a new User
	// (POST /user/register)
	CreateUser(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// CreateJar operation middleware
func (siw *ServerInterfaceWrapper) CreateJar(w http.ResponseWriter, r *http.Request) {
	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateJar(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteJar operation middleware
func (siw *ServerInterfaceWrapper) DeleteJar(w http.ResponseWriter, r *http.Request) {
	var err error

	// ------------- Path parameter "id" -------------
	var id JarID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteJar(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetJar operation middleware
func (siw *ServerInterfaceWrapper) GetJar(w http.ResponseWriter, r *http.Request) {
	var err error

	// ------------- Path parameter "id" -------------
	var id JarID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetJarParams

	headers := r.Header

	// ------------- Optional header parameter "X-Paste-Password" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Paste-Password")]; found {
		var XPastePassword string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Paste-Password", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Paste-Password", valueList[0], &XPastePassword, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Paste-Password", Err: err})
			return
		}

		params.XPastePassword = XPastePassword

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetJar(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetJarScrolls operation middleware
func (siw *ServerInterfaceWrapper) GetJarScrolls(w http.ResponseWriter, r *http.Request) {
	var err error

	// ------------- Path parameter "id" -------------
	var id JarID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetJarScrolls(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Ping operation middleware
func (siw *ServerInterfaceWrapper) Ping(w http.ResponseWriter, r *http.Request) {
	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Ping(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteScroll operation middleware
func (siw *ServerInterfaceWrapper) DeleteScroll(w http.ResponseWriter, r *http.Request) {
	var err error

	// ------------- Path parameter "id" -------------
	var id ScrollID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteScroll(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetScroll operation middleware
func (siw *ServerInterfaceWrapper) GetScroll(w http.ResponseWriter, r *http.Request) {
	var err error

	// ------------- Path parameter "id" -------------
	var id ScrollID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScrollParams

	headers := r.Header

	// ------------- Optional header parameter "X-Paste-Password" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Paste-Password")]; found {
		var XPastePassword string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Paste-Password", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Paste-Password", valueList[0], &XPastePassword, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Paste-Password", Err: err})
			return
		}

		params.XPastePassword = XPastePassword

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetScroll(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PatchScroll operation middleware
func (siw *ServerInterfaceWrapper) PatchScroll(w http.ResponseWriter, r *http.Request) {
	var err error

	// ------------- Path parameter "id" -------------
	var id ScrollID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchScroll(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateScroll operation middleware
func (siw *ServerInterfaceWrapper) CreateScroll(w http.ResponseWriter, r *http.Request) {
	var err error

	// ------------- Path parameter "id" -------------
	var id JarID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateScroll(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateActivationToken operation middleware
func (siw *ServerInterfaceWrapper) CreateActivationToken(w http.ResponseWriter, r *http.Request) {
	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateActivationToken(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UploadScroll operation middleware
func (siw *ServerInterfaceWrapper) UploadScroll(w http.ResponseWriter, r *http.Request) {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadScrollParams

	headers := r.Header

	// ------------- Required header parameter "X-Upload-Token" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Upload-Token")]; found {
		var XUploadToken string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Upload-Token", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Upload-Token", valueList[0], &XUploadToken, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Upload-Token", Err: err})
			return
		}

		params.XUploadToken = XUploadToken

	} else {
		err := fmt.Errorf("Header parameter X-Upload-Token is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Upload-Token", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadScroll(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetUser operation middleware
func (siw *ServerInterfaceWrapper) GetUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ActivateUser operation middleware
func (siw *ServerInterfaceWrapper) ActivateUser(w http.ResponseWriter, r *http.Request) {
	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ActivateUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AuthUser operation middleware
func (siw *ServerInterfaceWrapper) AuthUser(w http.ResponseWriter, r *http.Request) {
	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AuthUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetUserJars operation middleware
func (siw *ServerInterfaceWrapper) GetUserJars(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUserJars(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateUser operation middleware
func (siw *ServerInterfaceWrapper) CreateUser(w http.ResponseWriter, r *http.Request) {
	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/jar", wrapper.CreateJar)
	m.HandleFunc("DELETE "+options.BaseURL+"/jar/{id}", wrapper.DeleteJar)
	m.HandleFunc("GET "+options.BaseURL+"/jar/{id}", wrapper.GetJar)
	m.HandleFunc("GET "+options.BaseURL+"/jar/{id}/scrolls", wrapper.GetJarScrolls)
	m.HandleFunc("GET "+options.BaseURL+"/ping", wrapper.Ping)
	m.HandleFunc("DELETE "+options.BaseURL+"/scroll/{id}", wrapper.DeleteScroll)
	m.HandleFunc("GET "+options.BaseURL+"/scroll/{id}", wrapper.GetScroll)
	m.HandleFunc("PATCH "+options.BaseURL+"/scroll/{id}", wrapper.PatchScroll)
	m.HandleFunc("POST "+options.BaseURL+"/scroll/{id}", wrapper.CreateScroll)
	m.HandleFunc("POST "+options.BaseURL+"/token/activation", wrapper.CreateActivationToken)
	m.HandleFunc("PUT "+options.BaseURL+"/upload", wrapper.UploadScroll)
	m.HandleFunc("GET "+options.BaseURL+"/user", wrapper.GetUser)
	m.HandleFunc("PUT "+options.BaseURL+"/user/activate", wrapper.ActivateUser)
	m.HandleFunc("POST "+options.BaseURL+"/user/auth", wrapper.AuthUser)
	m.HandleFunc("GET "+options.BaseURL+"/user/jars", wrapper.GetUserJars)
	m.HandleFunc("POST "+options.BaseURL+"/user/register", wrapper.CreateUser)

	return m
}
